# Modular Monolithic Architecture(모듈형 모노리스)
## 개요
모듈형 모노리스는 모노리스의 장점과 마이크로서비스의 단점을 보완한 새로운 형태의 아키텍처이다.
기본적으로 모노리스 형태이지만, 각 기능별 모듈화 하여 결합도를 낮추고 응집도를 높이는 방식으로 설계한다.
각 기능은 확장성을 가지면서 마이크로서비스로 전환할 수 있는 유연성을 가진다.

| 비교 항목       | 모놀리식 아키텍처                         | 모듈형 모노리스 아키텍처                                      | 마이크로서비스                                             |
|----------------|-----------------------------------------|-------------------------------------------------------------|----------------------------------------------------------|
| 배포 방식       | 단일 코드베이스와 단일 배포 단위           | 단일 코드베이스와 단일 배포 단위                                | 서비스별 독립 배포                                         |
| 코드 구조       | 전체 코드가 밀접하게 결합                 | 독립된 모듈로 나누어 코드 구조가 명확                             | 서비스별로 분리된 코드베이스                                |
| 확장성         | 기능별 확장 어려움                        | 모듈을 마이크로서비스로 전환할 수 있는 유연성 제공                 | 개별 서비스 확장 가능                                       |
| 유지보수성      | 규모가 커질수록 복잡성 증가               | 모듈화로 인해 유지보수와 기능별 개발 관리 용이                      | 서비스 분리로 인해 관리 복잡성 증가                           |
| 성능           | 모듈 간 내부 호출로 성능 우수               | 네트워크 통신 없이 빠른 모듈 호출 가능                            | 네트워크 통신 필요 (느림)                                   |
| 장애 격리       | 장애 발생 시 전체 시스템에 영향            | 장애 발생 시 다른 모듈에 미치는 영향 최소화 가능                    | 개별 서비스 장애 격리가 가능                                |
| 트랜잭션 관리   | 단일 트랜잭션 관리로 일관성 유지 가능       | 단일 트랜잭션 관리로 데이터 일관성 쉽게 유지                       | 분산 트랜잭션 관리 필요                                     |
| 설계 복잡성     | 단순한 구조                             | 모듈 간 의존성과 경계 설정으로 구조적 복잡성 증가                    | 서비스 간 API 의존성 관리가 필요                              |
| 모듈 간 호출     | 메모리 내부에서 호출 (빠름)              | 메모리 내부에서 호출 (빠름)                                   | 네트워크 통신 필요 (느림)                                   |
| 테스트와 디버깅  | 단일 애플리케이션에서 쉽게 통합 테스트 가능 | 단일 애플리케이션에서 쉽게 통합 테스트 가능                        | 서비스별 독립적 테스트 필요, 통합 테스트 복잡                    |
| 의존성 관리     | 같은 코드베이스에서 명확히 관리            | 같은 코드베이스에서 명확히 관리                                | 서비스 간 API 의존성 필요, 변경 시 각 서비스에 영향            |
| 장기 확장성     | 초기 개발 및 유지보수 편리하나 확장에 한계  | 모듈화로 유연한 확장 가능                                    | 큰 규모의 확장에 적합, 자유로운 서비스 추가 및 관리 가능        |

## 모듈 구성 및 패키지 구조
```
com.example.common         # 공통 모듈
├── config                 # 공통 설정
├── dto                    # 공통 DTO 및 기본 엔티티
├── exception              # 공통 예외 및 예외 처리기
└── util                   # 공통 유틸리티 클래스

com.example.moduleA        # 모듈 A
├── controller             # 모듈 A의 컨트롤러
├── service                # 모듈 A의 서비스
└── repository             # 모듈 A의 레포지토리

com.example.moduleB        # 모듈 B
├── controller             # 모듈 B의 컨트롤러
├── service                # 모듈 B의 서비스
└── repository             # 모듈 B의 레포지토리
```
common 모듈 외에는 다른 모듈과 의존성을 갖지 않도록 결합도를 낮춘다.
공통 기능을 common 모듈에 배치하고, 최초 개별 모듈 단일 배포 시, common 모듈은 넥서스 배포하여 다른 모듈이 참조하도록 한다.
